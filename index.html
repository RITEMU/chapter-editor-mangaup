<!DOCTYPE html><html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Processor</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
font-family: Arial, sans-serif;
}

body {
background: #f0f2f5;
padding: 20px;
}

.container {
max-width: 800px;
margin: 0 auto;
background: white;
padding: 30px;
border-radius: 10px;
box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.form-group {
margin-bottom: 20px;
}

label {
display: block;
margin-bottom: 8px;
font-weight: bold;
color: #333;
}

input[type="number"],
input[type="file"],
select {
width: 100%;
padding: 10px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 16px;
}

input[type="checkbox"] {
margin-right: 8px;
}

button {
background: #4CAF50;
color: white;
padding: 12px 24px;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
width: 100%;
}

button:hover {
background: #45a049;
}

button:disabled {
background: #cccccc;
cursor: not-allowed;
}

.preview-container {
margin: 20px 0;
padding: 15px;
border: 2px dashed #ddd;
border-radius: 5px;
min-height: 100px;
}

.preview-image {
max-width: 150px;
margin: 5px;
border: 1px solid #ddd;
}

.progress-bar {
width: 100%;
height: 20px;
background-color: #f0f0f0;
border-radius: 10px;
overflow: hidden;
margin-top: 20px;
}

.progress-fill {
height: 100%;
background-color: #4CAF50;
width: 0%;
transition: width 0.3s ease;
}

#dimensionsGroup {
display: block;
}
</style>
</head>
<body>
<div class="container">
<h1 style="margin-bottom: 20px;">Image Processor</h1>

<div class="form-group">
<label for="fileInput">Select Image Files or Folders:</label>
<input type="file" id="fileInput" multiple accept="image/*" webkitdirectory directory>
</div>

<div class="preview-container" id="previewContainer">
<p id="noFilesMessage">No files selected</p>
</div>

<div class="form-group">
<label>
<input type="checkbox" id="mergeCheckbox" checked>
Merge Images
</label>
</div>

<div id="dimensionsGroup">
<div class="form-group">
<label for="widthInput">Width (px):</label>
<input type="number" id="widthInput" value="800" min="1">
</div>

<div class="form-group">
<label for="heightInput">Maximum Height (px):</label>
<input type="number" id="heightInput" value="14000" min="1">
</div>
</div>

<div class="form-group">
<label for="formatSelect">Output Format:</label>
<select id="formatSelect">
<option value="webp">WebP</option>
<option value="jpeg">JPEG</option>
<option value="png">PNG</option>
</select>
</div>

<div class="form-group">
<label for="qualityInput">Quality (%):</label>
<input type="number" id="qualityInput" value="100" min="1" max="100">
</div>

<button id="processButton" disabled>Process Images</button>

<div class="progress-bar">
<div class="progress-fill" id="progressBar"></div>
</div>
</div>

<script>
const fileInput = document.getElementById('fileInput');
const mergeCheckbox = document.getElementById('mergeCheckbox');
const widthInput = document.getElementById('widthInput');
const heightInput = document.getElementById('heightInput');
const formatSelect = document.getElementById('formatSelect');
const qualityInput = document.getElementById('qualityInput');
const processButton = document.getElementById('processButton');
const previewContainer = document.getElementById('previewContainer');
const dimensionsGroup = document.getElementById('dimensionsGroup');
const progressBar = document.getElementById('progressBar');
const noFilesMessage = document.getElementById('noFilesMessage');

let selectedFiles = [];

mergeCheckbox.addEventListener('change', () => {
dimensionsGroup.style.display = mergeCheckbox.checked ? 'block' : 'none';
});

fileInput.addEventListener('change', (e) => {
selectedFiles = Array.from(e.target.files).filter(file => 
file.type.startsWith('image/'));

previewContainer.innerHTML = '';
if (selectedFiles.length === 0) {
previewContainer.appendChild(noFilesMessage);
processButton.disabled = true;
return;
}

processButton.disabled = false;

// Group files by directory
const filesByDirectory = {};
selectedFiles.forEach(file => {
const path = file.webkitRelativePath;
const directory = path.split('/')[0];
if (!filesByDirectory[directory]) {
filesByDirectory[directory] = [];
}
filesByDirectory[directory].push(file);
});

// Display preview by directory
Object.entries(filesByDirectory).forEach(([directory, files]) => {
const dirElement = document.createElement('div');
dirElement.innerHTML = `<h3 style="margin: 10px 0;">${directory}</h3>`;

files.forEach(file => {
const reader = new FileReader();
reader.onload = (e) => {
const img = document.createElement('img');
img.src = e.target.result;
img.className = 'preview-image';
dirElement.appendChild(img);
};
reader.readAsDataURL(file);
});

previewContainer.appendChild(dirElement);
});
});

async function processImages() {
if (selectedFiles.length === 0) return;

const width = parseInt(widthInput.value);
const maxHeight = parseInt(heightInput.value);
const quality = parseInt(qualityInput.value) / 100;
const format = formatSelect.value;
const shouldMerge = mergeCheckbox.checked;

// Group files by directory
const filesByDirectory = {};
selectedFiles.forEach(file => {
const path = file.webkitRelativePath;
const directory = path.split('/')[0];
if (!filesByDirectory[directory]) {
filesByDirectory[directory] = [];
}
filesByDirectory[directory].push(file);
});

const zip = new JSZip();
let processedDirs = 0;
const totalDirs = Object.keys(filesByDirectory).length;

for (const [directory, files] of Object.entries(filesByDirectory)) {
const dirZip = zip.folder(directory);

if (shouldMerge) {
// Process and merge images
const images = await Promise.all(files.map(async file => {
const img = await createImageBitmap(file);
return img;
}));

// Calculate total height
let totalHeight = images.reduce((sum, img) => {
const scaledHeight = (width / img.width) * img.height;
return sum + scaledHeight;
}, 0);

// Calculate number of output images needed
const numOutputImages = Math.ceil(totalHeight / maxHeight);
let currentHeight = 0;
let currentCanvas = document.createElement('canvas');
currentCanvas.width = width;
currentCanvas.height = maxHeight;
let ctx = currentCanvas.getContext('2d');
let imageIndex = 1;

for (let i = 0; i < images.length; i++) {
const scaledHeight = (width / images[i].width) * images[i].height;

if (currentHeight + scaledHeight > maxHeight) {
// Save current canvas
const blob = await new Promise(resolve => {
currentCanvas.toBlob(resolve, `image/${format}`, quality);
});
dirZip.file(`${String(imageIndex).padStart(3, '0')}.${format}`, blob);
imageIndex++;

// Create new canvas
currentCanvas = document.createElement('canvas');
currentCanvas.width = width;
currentCanvas.height = maxHeight;
ctx = currentCanvas.getContext('2d');
currentHeight = 0;
}

ctx.drawImage(images[i], 0, currentHeight, width, scaledHeight);
currentHeight += scaledHeight;
}

// Save final canvas if it has content
if (currentHeight > 0) {
const finalCanvas = document.createElement('canvas');
finalCanvas.width = width;
finalCanvas.height = currentHeight;
const finalCtx = finalCanvas.getContext('2d');
finalCtx.drawImage(currentCanvas, 0, 0);

const blob = await new Promise(resolve => {
finalCanvas.toBlob(resolve, `image/${format}`, quality);
});
dirZip.file(`${String(imageIndex).padStart(3, '0')}.${format}`, blob);
}
} else {
// Just convert format and quality
for (let i = 0; i < files.length; i++) {
const img = await createImageBitmap(files[i]);
const canvas = document.createElement('canvas');
canvas.width = img.width;
canvas.height = img.height;
const ctx = canvas.getContext('2d');
ctx.drawImage(img, 0, 0);

const blob = await new Promise(resolve => {
canvas.toBlob(resolve, `image/${format}`, quality);
});
dirZip.file(`${String(i + 1).padStart(3, '0')}.${format}`, blob);
}
}

processedDirs++;
progressBar.style.width = `${(processedDirs / totalDirs) * 100}%`;
}

// Generate and download zip
const content = await zip.generateAsync({type: 'blob'});
const link = document.createElement('a');
link.href = URL.createObjectURL(content);
link.download = 'processed_images.zip';
link.click();
URL.revokeObjectURL(link.href);

progressBar.style.width = '100%';
setTimeout(() => {
progressBar.style.width = '0%';
}, 1000);
}

processButton.addEventListener('click', processImages);
</script>
</body>
</html>
