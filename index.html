 Let me help create a complete web application for processing and merging images according to your specifications. Given the complexity and functionality required, I'll create a single HTML file with embedded JavaScript that handles all the image processing.




<html_artifact><!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>پردازشگر تصویر</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f5f5f5;
            --border-color: #ddd;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: #f0f2f5;
            padding: 2rem;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h1 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .form-control {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
        }

        .file-list {
            margin: 1rem 0;
            padding: 1rem;
            background: var(--secondary-color);
            border-radius: 0.5rem;
            min-height: 100px;
        }

        .file-item {
            padding: 0.5rem;
            margin: 0.25rem 0;
            background: white;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .folder-name {
            font-weight: bold;
            margin: 1rem 0 0.5rem 0;
        }

        .btn {
            background: var(--primary-color);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            width: 100%;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #357abd;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .progress-container {
            margin-top: 1rem;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: var(--secondary-color);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress {
            width: 0%;
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>پردازشگر تصویر</h1>
            <p>ابزار ترکیب و تغییر سایز تصاویر</p>
        </div>

        <div class="form-group">
            <label>انتخاب پوشه‌ها:</label>
            <input type="file" class="form-control" id="fileInput" webkitdirectory directory multiple accept="image/*">
        </div>

        <div class="file-list" id="fileList"></div>

        <div class="form-group checkbox-group">
            <input type="checkbox" id="mergeCheckbox" checked>
            <label for="mergeCheckbox">چسباندن تصاویر</label>
        </div>

        <div id="dimensionsGroup">
            <div class="form-group">
                <label>عرض تصویر (پیکسل):</label>
                <input type="number" class="form-control" id="widthInput" value="800">
            </div>

            <div class="form-group">
                <label>حداکثر طول (پیکسل):</label>
                <input type="number" class="form-control" id="maxHeightInput" value="12000">
            </div>
        </div>

        <div class="form-group">
            <label>فرمت خروجی:</label>
            <select class="form-control" id="formatSelect">
                <option value="webp">WebP</option>
                <option value="jpeg">JPEG</option>
                <option value="png">PNG</option>
            </select>
        </div>

        <div class="form-group">
            <label>کیفیت خروجی (%):</label>
            <input type="number" class="form-control" id="qualityInput" value="100" min="1" max="100">
        </div>

        <button class="btn" id="processButton">شروع پردازش</button>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress" id="progressBar"></div>
            </div>
        </div>
    </div>

    <script>
        let filesByFolder = new Map();

        // Elements
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const mergeCheckbox = document.getElementById('mergeCheckbox');
        const dimensionsGroup = document.getElementById('dimensionsGroup');
        const widthInput = document.getElementById('widthInput');
        const maxHeightInput = document.getElementById('maxHeightInput');
        const formatSelect = document.getElementById('formatSelect');
        const qualityInput = document.getElementById('qualityInput');
        const processButton = document.getElementById('processButton');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');

        // Event Listeners
        mergeCheckbox.addEventListener('change', () => {
            dimensionsGroup.classList.toggle('hidden', !mergeCheckbox.checked);
        });

        fileInput.addEventListener('change', handleFileSelect);
        processButton.addEventListener('change', processImages);

        function handleFileSelect(event) {
            filesByFolder.clear();
            const files = Array.from(event.target.files).filter(file => 
                file.type.startsWith('image/'));

            // Group files by folder
            files.forEach(file => {
                const pathParts = file.webkitRelativePath.split('/');
                const folderName = pathParts[0];
                
                if (!filesByFolder.has(folderName)) {
                    filesByFolder.set(folderName, []);
                }
                filesByFolder.get(folderName).push(file);
            });

            // Display files
            displayFiles();
        }

        function displayFiles() {
            fileList.innerHTML = '';
            
            filesByFolder.forEach((files, folderName) => {
                const folderDiv = document.createElement('div');
                folderDiv.innerHTML = `<div class="folder-name">${folderName}/</div>`;
                
                const fileListDiv = document.createElement('div');
                fileListDiv.classList.add('folder-files');
                
                files.forEach(file => {
                    const fileDiv = document.createElement('div');
                    fileDiv.classList.add('file-item');
                    fileDiv.draggable = true;
                    fileDiv.innerHTML = `└── ${file.name}`;
                    fileListDiv.appendChild(fileDiv);
                });
                
                folderDiv.appendChild(fileListDiv);
                fileList.appendChild(folderDiv);
            });

            // Enable drag and drop reordering
            setupDragAndDrop();
        }

        function setupDragAndDrop() {
            const fileItems = document.querySelectorAll('.file-item');
            
            fileItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.innerHTML);
            e.target.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            const draggedData = e.dataTransfer.getData('text/plain');
            const draggedElement = document.querySelector('.dragging');
            const dropTarget = e.target;

            if (draggedElement && dropTarget.classList.contains('file-item')) {
                const parent = dropTarget.parentNode;
                const temp = dropTarget.innerHTML;
                dropTarget.innerHTML = draggedData;
                draggedElement.innerHTML = temp;
            }

            document.querySelector('.dragging')?.classList.remove('dragging');
        }

        async function processImages() {
            try {
                progressContainer.style.display = 'block';
                processButton.disabled = true;

                const width = parseInt(widthInput.value);
                const maxHeight = parseInt(maxHeightInput.value);
                const quality = parseInt(qualityInput.value) / 100;
                const format = formatSelect.value;
                const shouldMerge = mergeCheckbox.checked;

                for (const [folderName, files] of filesByFolder) {
                    const zip = new JSZip();
                    let processedFiles = [];

                    if (shouldMerge) {
                        // Process and merge images
                        const canvases = await Promise.all(files.map(async (file, index) => {
                            const img = await createImageFromFile(file);
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Calculate new dimensions maintaining aspect ratio
                            const aspectRatio = img.width / img.height;
                            const newHeight = Math.round(width / aspectRatio);
                            
                            canvas.width = width;
                            canvas.height = newHeight;
                            
                            ctx.drawImage(img, 0, 0, width, newHeight);
                            return canvas;
                        }));

                        // Merge canvases vertically
                        const mergedCanvas = document.createElement('canvas');
                        const ctx = mergedCanvas.getContext('2d');
                        
                        const totalHeight = canvases.reduce((sum, canvas) => sum + canvas.height, 0);
                        let currentY = 0;
                        
                        mergedCanvas.width = width;
                        mergedCanvas.height = totalHeight;
                        
                        canvases.forEach(canvas => {
                            ctx.drawImage(canvas, 0, currentY);
                            currentY += canvas.height;
                        });

                        // Split merged image
                        const numFullImages = Math.floor(totalHeight / maxHeight);
                        const remainingHeight = totalHeight % maxHeight;

                        for (let i = 0; i < numFullImages; i++) {
                            const splitCanvas = document.createElement('canvas');
                            splitCanvas.width = width;
                            splitCanvas.height = maxHeight;
                            
                            const splitCtx = splitCanvas.getContext('2d');
                            splitCtx.drawImage(
                                mergedCanvas,
                                0, i * maxHeight,
                                width, maxHeight,
                                0, 0,
                                width, maxHeight
                            );

                            const fileName = `${(i + 1).toString().padStart(3, '0')}.${format}`;
                            const blob = await canvasToBlob(splitCanvas, format, quality);
                            zip.file(fileName, blob);
                            processedFiles.push(fileName);
                        }

                        if (remainingHeight > 0) {
                            const splitCanvas = document.createElement('canvas');
                            splitCanvas.width = width;
                            splitCanvas.height = remainingHeight;
                            
                            const splitCtx = splitCanvas.getContext('2d');
                            splitCtx.drawImage(
                                mergedCanvas,
                                0, numFullImages * maxHeight,
                                width, remainingHeight,
                                0, 0,
                                width, remainingHeight
                            );

                            const fileName = `${(numFullImages + 1).toString().padStart(3, '0')}.${format}`;
                            const blob = await canvasToBlob(splitCanvas, format, quality);
                            zip.file(fileName, blob);
                            processedFiles.push(fileName);
                        }
                    } else {
                        // Just convert format and quality
                        await Promise.all(files.map(async (file, index) => {
                            const img = await createImageFromFile(file);
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            const fileName = `${(index + 1).toString().padStart(3, '0')}.${format}`;
                            const blob = await canvasToBlob(canvas, format, quality);
                            zip.file(fileName, blob);
                            processedFiles.push(fileName);
                        }));
                    }

                    // Generate and download zip
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    saveAs(zipBlob, `${folderName}.zip`);

                    // Update progress
                    progressBar.style.width = `${((Array.from(filesByFolder.keys()).indexOf(folderName) + 1) / filesByFolder.size) * 100}%`;
                }

                progressContainer.style.display = 'none';
                processButton.disabled = false;
                alert('پردازش با موفقیت انجام شد!');

            } catch (error) {
                console.error('Error processing images:', error);
                alert('خطا در پردازش تصاویر');
                progressContainer.style.display = 'none';
                processButton.disabled = false;
            }
        }

        function createImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(</html_artifact>
