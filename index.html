<!DOCTYPE html><html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>پردازشگر تصویر</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<style>
:root {
--primary: #4a90e2;
--secondary: #2c3e50;
--success: #27ae60;
--background: #f5f6fa;
--border: #dcdde1;
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

body {
background: var(--background);
padding: 2rem;
direction: rtl;
}

.container {
max-width: 1200px;
margin: 0 auto;
background: white;
padding: 2rem;
border-radius: 1rem;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

h1 {
color: var(--secondary);
margin-bottom: 2rem;
text-align: center;
}

.form-group {
margin-bottom: 1.5rem;
}

label {
display: block;
margin-bottom: 0.5rem;
color: var(--secondary);
font-weight: 500;
}

input[type="number"],
input[type="file"],
select {
width: 100%;
padding: 0.75rem;
border: 2px solid var(--border);
border-radius: 0.5rem;
font-size: 1rem;
transition: border-color 0.3s;
}

input[type="number"]:focus,
input[type="file"]:focus,
select:focus {
outline: none;
border-color: var(--primary);
}

.checkbox-group {
display: flex;
align-items: center;
gap: 0.5rem;
margin-bottom: 1.5rem;
}

input[type="checkbox"] {
width: 1.2rem;
height: 1.2rem;
}

button {
background: var(--primary);
color: white;
border: none;
padding: 1rem 2rem;
border-radius: 0.5rem;
font-size: 1rem;
cursor: pointer;
width: 100%;
transition: background 0.3s;
}

button:hover {
background: #357abd;
}

button:disabled {
background: #ccc;
cursor: not-allowed;
}

.preview-container {
margin-top: 2rem;
padding: 1rem;
border: 2px dashed var(--border);
border-radius: 0.5rem;
min-height: 200px;
}

.preview-item {
display: flex;
align-items: center;
padding: 0.5rem;
background: var(--background);
margin-bottom: 0.5rem;
border-radius: 0.5rem;
}

.preview-item span {
margin-right: 1rem;
}

.progress-container {
margin-top: 1rem;
}

.progress-bar {
width: 100%;
height: 20px;
background-color: var(--border);
border-radius: 10px;
overflow: hidden;
display: none;
}

.progress {
width: 0%;
height: 100%;
background-color: var(--success);
transition: width 0.3s;
}

.progress-text {
text-align: center;
margin-top: 0.5rem;
font-size: 0.9rem;
color: var(--secondary);
}

.hidden {
display: none;
}

#canvas {
display: none;
}

@media (max-width: 768px) {
body {
padding: 1rem;
}

.container {
padding: 1rem;
}
}
</style>
</head>
<body>
<div class="container">
<h1>پردازشگر تصویر</h1>

<div class="form-group">
<label>انتخاب فایل‌ها:</label>
<input type="file" id="fileInput" multiple accept=".jpg,.jpeg,.png,.webp" webkitdirectory directory>
</div>

<div class="checkbox-group">
<input type="checkbox" id="mergeCheck" checked>
<label for="mergeCheck">چسباندن تصاویر</label>
</div>

<div id="dimensionsGroup">
<div class="form-group">
<label>عرض تصویر (پیکسل):</label>
<input type="number" id="widthInput" value="800" min="1">
</div>

<div class="form-group">
<label>حداکثر طول تصویر (پیکسل):</label>
<input type="number" id="heightInput" value="12000" min="1">
</div>
</div>

<div class="form-group">
<label>فرمت خروجی:</label>
<select id="formatSelect">
<option value="webp">WebP</option>
<option value="jpeg">JPG</option>
<option value="png">PNG</option>
</select>
</div>

<div class="form-group">
<label>کیفیت خروجی (%):</label>
<input type="number" id="qualityInput" value="100" min="1" max="100">
</div>

<button id="processButton" disabled>شروع پردازش</button>

<div class="preview-container" id="previewContainer">
<div id="fileList"></div>
</div>

<div class="progress-container">
<div class="progress-bar" id="progressBar">
<div class="progress" id="progress"></div>
</div>
<div class="progress-text" id="progressText"></div>
</div>
</div>

<canvas id="canvas"></canvas>

<script>
const fileInput = document.getElementById('fileInput');
const mergeCheck = document.getElementById('mergeCheck');
const widthInput = document.getElementById('widthInput');
const heightInput = document.getElementById('heightInput');
const formatSelect = document.getElementById('formatSelect');
const qualityInput = document.getElementById('qualityInput');
const processButton = document.getElementById('processButton');
const previewContainer = document.getElementById('previewContainer');
const fileList = document.getElementById('fileList');
const progressBar = document.getElementById('progressBar');
const progress = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const dimensionsGroup = document.getElementById('dimensionsGroup');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let selectedFiles = [];
let chapters = {};

mergeCheck.addEventListener('change', () => {
dimensionsGroup.classList.toggle('hidden', !mergeCheck.checked);
});

fileInput.addEventListener('change', () => {
fileList.innerHTML = '';
selectedFiles = Array.from(fileInput.files);
processButton.disabled = selectedFiles.length === 0;

chapters = {};
selectedFiles.forEach(file => {
if (file.type.startsWith('image/')) {
const pathParts = file.webkitRelativePath.split('/');
const chapter = pathParts[0];

if (!chapters[chapter]) {
chapters[chapter] = [];
}
chapters[chapter].push(file);
}
});

for (const [chapter, files] of Object.entries(chapters)) {
const chapterDiv = document.createElement('div');
chapterDiv.innerHTML = `<strong>${chapter}</strong>`;
fileList.appendChild(chapterDiv);

files.forEach(file => {
const fileDiv = document.createElement('div');
fileDiv.className = 'preview-item';
fileDiv.textContent = `${file.name} (${formatFileSize(file.size)})`;
fileList.appendChild(fileDiv);
});
}
});

function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

async function loadImage(file) {
return new Promise((resolve, reject) => {
const img = new Image();
img.onload = () => resolve(img);
img.onerror = reject;
img.src = URL.createObjectURL(file);
});
}

async function processImage(img, targetWidth, maxHeight, quality) {
const aspectRatio = img.width / img.height;
const targetHeight = Math.round(targetWidth / aspectRatio);

canvas.width = targetWidth;
canvas.height = targetHeight;

ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

return canvas.toDataURL(`image/${formatSelect.value}`, quality / 100);
}

async function mergeImages(images, targetWidth, maxHeight) {
const totalHeight = images.reduce((sum, img) => {
const aspectRatio = img.width / img.height;
return sum + Math.round(targetWidth / aspectRatio);
}, 0);

const segments = Math.ceil(totalHeight / maxHeight);
const segmentHeight = Math.ceil(totalHeight / segments);

canvas.width = targetWidth;
canvas.height = segmentHeight;

let results = [];
let currentY = 0;
let currentSegment = 0;
let currentSegmentHeight = 0;

for (const img of images) {
const aspectRatio = img.width / img.height;
const scaledHeight = Math.round(targetWidth / aspectRatio);

if (currentSegmentHeight + scaledHeight > segmentHeight) {
// Save current segment
const quality = qualityInput.value / 100;
const dataUrl = canvas.toDataURL(`image/${formatSelect.value}`, quality);
results.push(dataUrl);

// Clear canvas for next segment
currentY = 0;
currentSegment++;
currentSegmentHeight = 0;
ctx.clearRect(0, 0, canvas.width, canvas.height);
}

ctx.drawImage(img, 0, currentY, targetWidth, scaledHeight);
currentY += scaledHeight;
currentSegmentHeight += scaledHeight;
}

// Save last segment
if (currentSegmentHeight > 0) {
const quality = qualityInput.value / 100;
const dataUrl = canvas.toDataURL(`image/${formatSelect.value}`, quality);
results.push(dataUrl);
}

return results;
}

async function processChapter(files) {
const images = await Promise.all(files.map(loadImage));
const targetWidth = parseInt(widthInput.value);
const maxHeight = parseInt(heightInput.value);

if (mergeCheck.checked) {
return await mergeImages(images, targetWidth, maxHeight);
} else {
return await Promise.all(images.map(img => 
processImage(img, targetWidth, maxHeight, parseInt(qualityInput.value))
));
}
}

processButton.addEventListener('click', async () => {
processButton.disabled = true;
progressBar.style.display = 'block';
progress.style.width = '0%';
progressText.textContent = 'در حال پردازش...';

try {
const zip = new JSZip();
const totalChapters = Object.keys(chapters).length;
let processedChapters = 0;

for (const [chapter, files] of Object.entries(chapters)) {
const chapterZip = zip.folder(chapter);
const processedImages = await processChapter(files);

processedImages.forEach((dataUrl, index) => {
const imageData = dataUrl.split(',')[1];
const fileName = `${String(index + 1).padStart(3, '0')}.${formatSelect.value}`;
chapterZip.file(fileName, imageData, {base64: true});
});

processedChapters++;
const percentage = (processedChapters / totalChapters) * 100;
progress.style.width = percentage + '%';
progressText.textContent = `پردازش ${chapter} تمام شد (${Math.round(percentage)}%)`;
}

const content = await zip.generateAsync({type: 'blob'});
const downloadUrl = URL.createObjectURL(content);
const downloadLink = document.createElement('a');
downloadLink.href = downloadUrl;
downloadLink.download = 'processed_images.zip';
document.body.appendChild(downloadLink);
downloadLink.click();
document.body.removeChild(downloadLink);
URL.revokeObjectURL(downloadUrl);

progressText.textContent = 'پردازش با موفقیت انجام شد!';
} catch (error) {
console.error(error);
progressText.textContent = 'خطا در پردازش تصاویر';
} finally {
processButton.disabled = false;
setTimeout(() => {
progressBar.style.display = 'none';
progress.style.width = '0%';
}, 3000);
}
});
</script>
</body>
</html>
